"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CacheEntry = void 0;

var _sha = _interopRequireDefault(require("crypto-js/sha1"));

var _uniqueId = _interopRequireDefault(require("lodash/uniqueId"));

var _reactNativeFileAccess = require("react-native-file-access");

var _defaultConfiguration = _interopRequireDefault(require("./defaultConfiguration"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class CacheEntry {
  constructor(source, options, noCache, maxAge) {
    _defineProperty(this, "source", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "downloadPromise", void 0);

    _defineProperty(this, "pathResolved", false);

    _defineProperty(this, "noCache", false);

    _defineProperty(this, "maxAge", void 0);

    this.noCache = noCache;
    this.options = options;
    this.source = source;
    this.maxAge = maxAge;
  }

  async getPath() {
    const {
      source,
      maxAge,
      noCache
    } = this;
    const {
      exists,
      path,
      tmpPath
    } = await getCacheEntry(source, maxAge);

    if (exists && !noCache) {
      return path;
    }

    if (!this.downloadPromise) {
      this.pathResolved = false;
      this.downloadPromise = this.download(path, tmpPath);
    }

    if (this.downloadPromise && this.pathResolved) {
      this.pathResolved = false;
      this.downloadPromise = this.download(path, tmpPath);
    }

    return this.downloadPromise;
  }

  async download(path, tmpPath) {
    const {
      source,
      options,
      noCache
    } = this; // if noCache is true then return the source uri without caching it

    if (noCache) {
      return source;
    }

    if (source != null) {
      const result = await _reactNativeFileAccess.FileSystem.fetch(source, {
        path: tmpPath,
        ...options
      }); // If the image download failed, we don't cache anything

      if (result && result.status !== 200) {
        this.downloadPromise = undefined;
        return undefined;
      }

      await _reactNativeFileAccess.FileSystem.mv(tmpPath, path);

      if (CacheManager.config.cacheLimit) {
        await CacheManager.pruneCache();
      }

      this.pathResolved = true;
      return path;
    }

    return source;
  }

}

exports.CacheEntry = CacheEntry;

class CacheManager {
  get config() {
    return CacheManager.defaultConfig;
  }

  set config(newConfig) {
    CacheManager.defaultConfig = newConfig;
  }

  static get(source, options, noCache, maxAge) {
    if (!CacheManager.entries[source]) {
      CacheManager.entries[source] = new CacheEntry(source, options, noCache, maxAge);
      return CacheManager.entries[source];
    }

    return CacheManager.entries[source];
  }

  static async clearCache() {
    const files = await _reactNativeFileAccess.FileSystem.ls(CacheManager.config.baseDir);

    for (const file of files) {
      try {
        await _reactNativeFileAccess.FileSystem.unlink(`${CacheManager.config.baseDir}${file}`);
      } catch (e) {
        console.log(`error while clearing images cache, error: ${e}`);
      }
    }
  }

  static async removeCacheEntry(entry) {
    try {
      const file = await getCacheEntry(entry);
      const {
        path
      } = file;
      await _reactNativeFileAccess.FileSystem.unlink(path);
    } catch (e) {
      throw new Error('error while clearing image from cache');
    }
  }

  static async getCacheSize() {
    const result = await _reactNativeFileAccess.FileSystem.stat(CacheManager.config.baseDir);

    if (!result) {
      throw new Error(`${CacheManager.config.baseDir} not found`);
    }

    return result.size;
  }

  static async isImageCached(entry) {
    try {
      const file = await getCacheEntry(entry);
      const {
        exists
      } = file;
      return exists;
    } catch (e) {
      throw new Error('Error while checking if image already exists on cache');
    }
  }

  static prefetch(source, options) {
    if (typeof source === 'string') {
      CacheManager.get(source, options).getPath();
    } else {
      source.map(image => {
        CacheManager.get(image, options).getPath();
      });
    }
  }

  static async prefetchBlob(source, options) {
    const path = await CacheManager.get(source, options).getPath();

    if (path) {
      const blob = await _reactNativeFileAccess.FileSystem.readFile(path, 'base64');
      return blob;
    }

    return undefined;
  }

  static async pruneCache() {
    // If cache directory does not exist yet there's no need for pruning.
    if (!(await CacheManager.getCacheSize())) {
      return;
    }

    const files = await _reactNativeFileAccess.FileSystem.statDir(CacheManager.config.baseDir);
    files.sort((a, b) => {
      return a.lastModified - b.lastModified;
    });
    const currentCacheSize = files.reduce((cacheSize, file) => {
      return cacheSize + file.size;
    }, 0);

    if (currentCacheSize > CacheManager.config.cacheLimit) {
      let overflowSize = currentCacheSize - CacheManager.config.cacheLimit;

      while (overflowSize > 0 && files.length) {
        const file = files.shift();

        if (file) {
          if (await _reactNativeFileAccess.FileSystem.exists(file.path)) {
            overflowSize = overflowSize - file.size;
            await _reactNativeFileAccess.FileSystem.unlink(file.path).catch(e => console.log(e));
          }
        }
      }
    }
  }

}

exports.default = CacheManager;

_defineProperty(CacheManager, "defaultConfig", _defaultConfiguration.default);

_defineProperty(CacheManager, "config", void 0);

_defineProperty(CacheManager, "entries", {});

const getCacheEntry = async (cacheKey, maxAge) => {
  let newCacheKey = cacheKey;

  if (CacheManager.config.getCustomCacheKey) {
    newCacheKey = CacheManager.config.getCustomCacheKey(cacheKey);
  }

  const filename = cacheKey.substring(cacheKey.lastIndexOf('/'), cacheKey.indexOf('?') === -1 ? cacheKey.length : cacheKey.indexOf('?'));
  const ext = filename.indexOf('.') === -1 ? '.jpg' : filename.substring(filename.lastIndexOf('.'));
  const sha = (0, _sha.default)(newCacheKey);
  const path = `${CacheManager.config.baseDir}${sha}${ext}`;
  const tmpPath = `${CacheManager.config.baseDir}${sha}-${(0, _uniqueId.default)()}${ext}`; // TODO: maybe we don't have to do this every time

  try {
    await _reactNativeFileAccess.FileSystem.mkdir(CacheManager.config.baseDir);
  } catch (e) {// do nothing
  }

  const exists = await _reactNativeFileAccess.FileSystem.exists(path);

  if (maxAge && exists) {
    const {
      lastModified
    } = await _reactNativeFileAccess.FileSystem.stat(path);
    const ageInHours = Math.floor(Date.now() - lastModified) / 1000 / 3600;

    if (maxAge < ageInHours) {
      await _reactNativeFileAccess.FileSystem.unlink(path);
      return {
        exists: false,
        path,
        tmpPath
      };
    }
  }

  return {
    exists,
    path,
    tmpPath
  };
};
//# sourceMappingURL=CacheManager.js.map